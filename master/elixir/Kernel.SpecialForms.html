<!DOCTYPE html>
<html>
  <head>
    <title>Kernel.SpecialForms</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css" media="screen" charset="utf-8" />

    <script type="text/javascript" charset="utf-8">
      relpath = '';
      if (relpath != '') relpath += '/';
    </script>

    <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="js/app.js"></script>
  </head>

  <body>
    <script type="text/javascript" charset="utf-8">
      if (window.top.frames.main) document.body.className = 'frames';
    </script>

    <div id="content">
      <div class="breadcrumbs">Elixir v0.14.2-dev &rarr; <a href="overview.html">Overview</a> &rarr; <a href="Kernel.html">Kernel</a> &rarr; <a href="Kernel.SpecialForms.html">SpecialForms</a></div>

      <h1>
        Kernel.SpecialForms
        
      </h1>

      <ul class="summary_links">
        
          <li><a href="#summary">Summary</a></li>
        
        
        
          <li><a href="#macros_details">Macros</a></li>
        
        
        
      </ul>

      
        <div id="moduledoc" class="docstring">
          <p>In this module we define Elixir special forms. Special forms
cannot be overridden by the developer and are the basic
building blocks of Elixir code.</p>

<p>Some of those forms are lexical (like <code>alias</code>, <code>case</code>, etc).
The macros <code>{}</code> and <code>&lt;&lt;&gt;&gt;</code> are also special forms used to define
tuple and binary data structures respectively.</p>

<p>This module also documents Elixir&#39;s pseudo variables (<code>__ENV__</code>,
<code>__MODULE__</code>, <code>__DIR__</code> and <code>__CALLER__</code>). Pseudo variables return
information about Elixir&#39;s compilation environment and can only
be read, never assigned to.</p>

<p>Finally, it also documents 2 special forms, <code>__block__</code> and
<code>__aliases__</code>, which are not intended to be called directly by the
developer but they appear in quoted contents since they are essential
in Elixir&#39;s constructs.</p>

        </div>
      

      
        <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1" class="view_source">Source</a>
      

      
        <h2 id="summary">Summary<div class="detail_header_links"><a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a></div></h2>
        <table class="summary">
          <tr>
  <td class="summary_signature"><a href="#%/2">%</a></td>
  
    <td class="summary_synopsis"><p>Creates a struct</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#%{}/1">%{}</a></td>
  
    <td class="summary_synopsis"><p>Creates a map</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#&amp;/1">&amp;expr</a></td>
  
    <td class="summary_synopsis"><p>Captures or creates an anonymous function</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#./2">left . right</a></td>
  
    <td class="summary_synopsis"><p>Defines a remote call or an alias</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#&lt;&lt;&gt;&gt;/1">&lt;&lt;args&gt;&gt;</a></td>
  
    <td class="summary_synopsis"><p>Defines a new bitstring</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#^/1">^var</a></td>
  
    <td class="summary_synopsis"><p>Accesses an already bound variable in match clauses</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__CALLER__/0">__CALLER__</a></td>
  
    <td class="summary_synopsis"><p>Returns the current calling environment as a <a href="Macro.Env.html"><code>Macro.Env</code></a> struct</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__DIR__/0">__DIR__</a></td>
  
    <td class="summary_synopsis"><p>Returns the current directory as a binary</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__ENV__/0">__ENV__</a></td>
  
    <td class="summary_synopsis"><p>Returns the current environment information as a <a href="Macro.Env.html"><code>Macro.Env</code></a> struct</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__MODULE__/0">__MODULE__</a></td>
  
    <td class="summary_synopsis"><p>Returns the current module name as an atom or <code>nil</code> otherwise</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__aliases__/1">__aliases__(args)</a></td>
  
    <td class="summary_synopsis"><p>Internal special form to hold aliases information</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#__block__/1">__block__(args)</a></td>
  
    <td class="summary_synopsis"><p>Internal special form for block expressions</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#alias/2">alias(module, opts)</a></td>
  
    <td class="summary_synopsis"><p><code>alias</code> is used to setup aliases, often useful with modules names</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#case/2">case(condition, blocks)</a></td>
  
    <td class="summary_synopsis"><p>Matches the given expression against the given clauses</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#fn/1">fn
  [clauses]
end</a></td>
  
    <td class="summary_synopsis"><p>Defines an anonymous function</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#for/1">for(args)</a></td>
  
    <td class="summary_synopsis"><p>Comprehensions allow you to quickly build a data structure from
an enumerable or a bitstring</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#import/2">import(module, opts)</a></td>
  
    <td class="summary_synopsis"><p>Imports function and macros from other modules</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#quote/2">quote(opts, block)</a></td>
  
    <td class="summary_synopsis"><p>Gets the representation of any expression</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#receive/1">receive(args)</a></td>
  
    <td class="summary_synopsis"><p>Checks if there is a message matching the given clauses
in the current process mailbox</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#require/2">require(module, opts)</a></td>
  
    <td class="summary_synopsis"><p>Requires a given module to be compiled and loaded</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#super/1">super(args)</a></td>
  
    <td class="summary_synopsis"><p>Calls the overriden function when overriding it with <code>defoverridable</code>.
See <code>Kernel.defoverridable</code> for more information and documentation</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#try/1">try(args)</a></td>
  
    <td class="summary_synopsis"><p>Evaluate the given expressions and handle any error, exit
or throw that may have happened</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#unquote/1">unquote(expr)</a></td>
  
    <td class="summary_synopsis"><p>Unquotes the given expression from inside a macro</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#unquote_splicing/1">unquote_splicing(expr)</a></td>
  
    <td class="summary_synopsis"><p>Unquotes the given list expanding its arguments. Similar
to unquote</p>
</td>
  
</tr>
<tr>
  <td class="summary_signature"><a href="#{}/1">{args}</a></td>
  
    <td class="summary_synopsis"><p>Creates a tuple</p>
</td>
  
</tr>

        </table>
      

      

      

      
        <div id="macros_details" class="details_list">
          <h2>Macros</h2>
          <div class="detail">
  <div class="detail_header" id="%/2">
    <span class="signature"><strong>%</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#%/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Creates a struct.</p>

<p>A struct is a tagged map that allows developers to provide
default values for keys, tags to be used in polymorphic
dispatches and compile time assertions.</p>

<p>To define a struct, you just need to implement the <code>__struct__/0</code>
function in a module:</p>

<pre><code>defmodule User do
  def __struct__ do
    %{name: &quot;josé&quot;, age: 27}
  end
end
</code></pre>

<p>In practice though, structs are usually defined with the
<code>Kernel.defstruct/2</code> macro:</p>

<pre><code>defmodule User do
  defstruct name: &quot;josé&quot;, age: 27
end
</code></pre>

<p>Now a struct can be created as follow:</p>

<pre><code>%User{}
</code></pre>

<p>Underneath a struct is just a map with a <code>__struct__</code> field
pointing to the User module:</p>

<pre><code>%User{} == %{__struct__: User, name: &quot;josé&quot;, age: 27}
</code></pre>

<p>A struct also validates the given keys are part of the defined
struct. The example below will fail because there is no key
<code>:full_name</code> in the user struct:</p>

<pre><code>%User{full_name: &quot;José Valim&quot;}
</code></pre>

<p>Note that a struct specifies a minimum set of keys required
for operations. Other keys can be added to structs via the
regular map operations:</p>

<pre><code>user = %User{}
Map.put(user, :a_non_struct_key, :value)
</code></pre>

<p>An update operation specific for structs is also available:</p>

<pre><code>%User{user | age: 28}
</code></pre>

<p>The syntax above will guarantee the given keys are valid at
compilation time and it will guarantee at runtime the given
argument is a struct, failing with <a href="BadStructError.html"><code>BadStructError</code></a> otherwise.</p>

<p>Alhought structs are maps, by default structs do not implement
any of the protocols implemented for maps. Check
<a href="Kernel.html#defprotocol/2"><code>Kernel.defprotocol/2</code></a> for more information on how structs
can be used with protocols for polymorphic dispatch. Also
see <a href="Kernel.html#struct/2"><code>Kernel.struct/2</code></a> for examples on how to create and update
structs dynamically.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L165" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="%{}/1">
    <span class="signature"><strong>%{}</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#%{}/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Creates a map.</p>

<p>Maps are key-value stores where keys are compared
using the match operator (<code>===</code>). Maps can be created with
the <code>%{}</code> special form where keys are associated via <code>=&gt;</code>:</p>

<pre><code>%{1 =&gt; 2}
</code></pre>

<p>Maps also support the keyword notation, as other special forms,
as long as they are at the end of the argument list:</p>

<pre><code>%{hello: :world, with: :keywords}
%{:hello =&gt; :world, with: :keywords}
</code></pre>

<p>If a map has duplicated keys, the last key will always have
higher precedence:</p>

<pre><code>iex&gt; %{a: :b, a: :c}
%{a: :c}
</code></pre>

<p>Conveniences for manipulating maps can be found in the
<a href="Map.html"><code>Map</code></a> module.</p>

<h2>Access syntax</h2>

<p>Besides the access functions available in the <a href="Map.html"><code>Map</code></a> module,
like <a href="Map.html#get/3"><code>Map.get/3</code></a> and <a href="Map.html#fetch/2"><code>Map.fetch/2</code></a>, a map can be accessed using the
<code>.</code> operator:</p>

<pre><code>iex&gt; map = %{a: :b}
iex&gt; map.a
:b
</code></pre>

<p>Note that the <code>.</code> operator expects the field to exist in the map.
If not, an <a href="ArgumentError.html"><code>ArgumentError</code></a> is raised.</p>

<h2>Update syntax</h2>

<p>Maps also support an update syntax:</p>

<pre><code>iex&gt; map = %{:a =&gt; :b}
iex&gt; %{map | :a =&gt; :c}
%{:a =&gt; :c}
</code></pre>

<p>Notice the update syntax requires the given keys to exist.
Trying to update a key that does not exist will raise an <a href="ArgumentError.html"><code>ArgumentError</code></a>.</p>

<h2>AST representation</h2>

<p>Regardless if <code>=&gt;</code> or the keywords syntax is used, Maps are
always represented internally as a list of two-items tuples
for simplicity:</p>

<pre><code>iex&gt; quote do: %{:a =&gt; :b, c: :d}
{:%{}, [], [{:a, :b}, {:c, :d}]}
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L103" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="&amp;/1">
    <span class="signature"><strong>&amp;expr</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#&amp;/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Captures or creates an anonymous function.</p>

<h2>Capture</h2>

<p>The capture operator is most commonly used to capture a
function with given name and arity from a module:</p>

<pre><code>iex&gt; fun = &amp;Kernel.is_atom/1
iex&gt; fun.(:atom)
true
iex&gt; fun.(&quot;string&quot;)
false
</code></pre>

<p>In the example above, we captured <a href="Kernel.html#is_atom/1"><code>Kernel.is_atom/1</code></a> as an
anonymous function and then invoked it.</p>

<p>The capture operator can also be used to capture local functions,
including private ones, and imported functions by omitting the
module name:</p>

<pre><code>&amp;local_function/1
</code></pre>

<h2>Anonymous functions</h2>

<p>The capture operator can also be used to partially apply
functions, where <code>&amp;1</code>, <code>&amp;2</code> and so on can be used as value
placeholders. For example:</p>

<pre><code>iex&gt; double = &amp;(&amp;1 * 2)
iex&gt; double.(2)
4
</code></pre>

<p>In other words, <code>&amp;(&amp;1 * 2)</code> is equivalent to <code>fn x -&gt; x * 2 end</code>.
Another example using a local function:</p>

<pre><code>iex&gt; fun = &amp;is_atom(&amp;1)
iex&gt; fun.(:atom)
true
</code></pre>

<p>The <code>&amp;</code> operator can be used with more complex expressions:</p>

<pre><code>iex&gt; fun = &amp;(&amp;1 + &amp;2 + &amp;3)
iex&gt; fun.(1, 2, 3)
6
</code></pre>

<p>As well as with lists and tuples:</p>

<pre><code>iex&gt; fun = &amp;{&amp;1, &amp;2}
iex&gt; fun.(1, 2)
{1, 2}

iex&gt; fun = &amp;[&amp;1|&amp;2]
iex&gt; fun.(1, 2)
[1|2]
</code></pre>

<p>The only restrictions when creating anonymous functions is that at
least one placeholder must be present, i.e. it must contain at least
<code>&amp;1</code>:</p>

<pre><code># No placeholder fails to compile
&amp;var

# Block expressions are also not supported
&amp;(foo(&amp;1, &amp;2); &amp;3 + &amp;4)
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1308" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="./2">
    <span class="signature"><strong>left . right</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#./2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Defines a remote call or an alias.</p>

<p>The dot (<code>.</code>) in Elixir can be used for remote calls:</p>

<pre><code>iex&gt; String.downcase(&quot;FOO&quot;)
&quot;foo&quot;
</code></pre>

<p>In this example above, we have used <code>.</code> to invoke <code>downcase</code> in the
<a href="String.html"><code>String</code></a> alias, passing &quot;FOO&quot; as argument. We can also use the dot
for creating aliases:</p>

<pre><code>iex&gt; Hello.World
Hello.World
</code></pre>

<p>This time, we have joined two aliases, defining the final alias
<code>Hello.World</code>.</p>

<h2>Syntax</h2>

<p>The right side of <code>.</code> may be a word starting in upcase, which represents
an alias, a word starting with lowercase or underscore, any valid language
operator or any name wrapped in single- or double-quotes. Those are all valid
examples:</p>

<pre><code>iex&gt; Kernel.Sample
Kernel.Sample

iex&gt; Kernel.length([1,2,3])
3

iex&gt; Kernel.+(1, 2)
3

iex&gt; Kernel.&quot;length&quot;([1,2,3])
3

iex&gt; Kernel.&#39;+&#39;(1, 2)
3
</code></pre>

<p>Note that <code>Kernel.&quot;HELLO&quot;</code> will be treated as a remote call and not an alias.
This choice was done so every time single- or double-quotes are used, we have
a remote call irregardless of the quote contents. This decision is also reflected
in the quoted expressions discussed below.</p>

<h2>Runtime (dynamic) behaviour</h2>

<p>The result returned by <code>.</code> is always specified by the right-side:</p>

<pre><code>iex&gt; x = String
iex&gt; x.downcase(&quot;FOO&quot;)
&quot;foo&quot;
iex&gt; x.Sample
String.Sample
</code></pre>

<p>In case the right-side is also dynamic, <code>.</code>&#39;s behaviour can be reproduced
at runtime via <code>apply/3</code> and <a href="Module.html#concat/2"><code>Module.concat/2</code></a>:</p>

<pre><code>iex&gt; apply(:erlang, :+, [1,2])
3

iex&gt; Module.concat(Kernel, Sample)
Kernel.Sample
</code></pre>

<h2>Quoted expression</h2>

<p>When <code>.</code> is used, the quoted expression may take two distinct
forms. When the right side starts with a lowercase letter (or
underscore):</p>

<pre><code>iex&gt; quote do: String.downcase(&quot;FOO&quot;)
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}
</code></pre>

<p>Notice we have an inner tuple, containing the atom <code>:.</code> representing
the dot as first element:</p>

<pre><code>{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}
</code></pre>

<p>This tuple follows the general quoted expression structure in Elixir,
with the name as first argument, some keyword list as metadata as second,
and the number of arguments as third. In this case, the arguments is the
alias <a href="String.html"><code>String</code></a> and the atom <code>:downcase</code>. The second argument is <strong>always</strong>
an atom:</p>

<pre><code>iex&gt; quote do: String.&quot;downcase&quot;(&quot;FOO&quot;)
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}
</code></pre>

<p>The tuple containing <code>:.</code> is wrapped in another tuple, which actually
represents the function call, and has <code>&quot;FOO&quot;</code> as argument.</p>

<p>When the right side is an alias (i.e. starts with uppercase), we get instead:</p>

<pre><code>iex&gt; quote do: Hello.World
{:__aliases__, [alias: false], [:Hello, :World]}
</code></pre>

<p>We got into more details about aliases in the <code>__aliases__</code> special form
documentation.</p>

<h2>Unquoting</h2>

<p>We can also use unquote to generate a remote call in a quoted expression:</p>

<pre><code>iex&gt; x = :downcase
iex&gt; quote do: String.unquote(x)(&quot;FOO&quot;)
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], [&quot;FOO&quot;]}
</code></pre>

<p>Similar to <code>Kernel.&quot;HELLO&quot;</code>, <code>unquote(x)</code> will always generate a remote call,
independent of the value of <code>x</code>. To generate an alias via the quoted expression,
one needs to rely on <a href="Module.html#concat/2"><code>Module.concat/2</code></a>:</p>

<pre><code>iex&gt; x = Sample
iex&gt; quote do: Module.concat(String, unquote(x))
{{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],
 [{:__aliases__, [alias: false], [:String]}, Sample]}
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L420" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="&lt;&lt;&gt;&gt;/1">
    <span class="signature"><strong>&lt;&lt;args&gt;&gt;</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#&lt;&lt;&gt;&gt;/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Defines a new bitstring.</p>

<h2>Examples</h2>

<pre><code>iex&gt; &lt;&lt; 1, 2, 3 &gt;&gt;
&lt;&lt; 1, 2, 3 &gt;&gt;
</code></pre>

<h2>Bitstring types</h2>

<p>A bitstring is made of many segments. Each segment has a
type, which defaults to integer:</p>

<pre><code>iex&gt; &lt;&lt;1, 2, 3&gt;&gt;
&lt;&lt;1, 2, 3&gt;&gt;
</code></pre>

<p>Elixir also accepts by default the segment to be a literal
string or a literal char list, which are by expanded to integers:</p>

<pre><code>iex&gt; &lt;&lt;0, &quot;foo&quot;&gt;&gt;
&lt;&lt;0, 102, 111, 111&gt;&gt;
</code></pre>

<p>Any other type needs to be explicitly tagged. For example,
in order to store a float type in the binary, one has to do:</p>

<pre><code>iex&gt; &lt;&lt;3.14 :: float&gt;&gt;
&lt;&lt;64, 9, 30, 184, 81, 235, 133, 31&gt;&gt;
</code></pre>

<p>This also means that variables need to be explicitly tagged,
otherwise Elixir defaults to integer:</p>

<pre><code>iex&gt; rest = &quot;oo&quot;
iex&gt; &lt;&lt;102, rest&gt;&gt;
** (ArgumentError) argument error
</code></pre>

<p>We can solve this by explicitly tagging it as a binary:</p>

<pre><code>&lt;&lt;102, rest :: binary&gt;&gt;
</code></pre>

<p>The type can be integer, float, bitstring/bits, binary/bytes,
utf8, utf16 or utf32, e.g.:</p>

<pre><code>&lt;&lt;102 :: float, rest :: binary&gt;&gt;
</code></pre>

<p>An integer can be any arbitrary precision integer. A float is an
IEEE 754 binary32 or binary64 floating point number. A bitstring
is an arbitrary series of bits. A binary is a special case of
bitstring that has a total size divisible by 8.</p>

<p>The utf8, utf16, and utf32 types are for UTF code points. They
can also be applied to literal strings and char lists:</p>

<pre><code>iex&gt; &lt;&lt;&quot;foo&quot; :: utf16&gt;&gt;
&lt;&lt;0,102,0,111,0,111&gt;&gt;
</code></pre>

<p>The bits type is an alias for bitstring. The bytes type is an
alias for binary.</p>

<p>The signedness can also be given as signed or unsigned. The
signedness only matters for matching. If unspecified, it
defaults to unsigned. Example:</p>

<pre><code>iex&gt; &lt;&lt;-100 :: signed, _rest :: binary&gt;&gt; = &lt;&lt;-100, &quot;foo&quot;&gt;&gt;
&lt;&lt;156,102,111,111&gt;&gt;
</code></pre>

<p>This match would have failed if we did not specify that the
value -100 is signed. If we&#39;re matching into a variable instead
of a value, the signedness won&#39;t be checked; rather, the number
will simply be interpreted as having the given (or implied)
signedness, e.g.:</p>

<pre><code>iex&gt; &lt;&lt;val, _rest :: binary&gt;&gt; = &lt;&lt;-100, &quot;foo&quot;&gt;&gt;
iex&gt; val
156
</code></pre>

<p>Here, <code>val</code> is interpreted as unsigned.</p>

<p>Signedness is only relevant on integers.</p>

<p>The endianness of a segment can be big, little or native (the
latter meaning it will be resolved at VM load time). Passing
many options can be done by giving a list:</p>

<pre><code>&lt;&lt;102 :: [integer, native], rest :: binary&gt;&gt;
</code></pre>

<p>Or:</p>

<pre><code>&lt;&lt;102 :: [unsigned, big, integer], rest :: binary&gt;&gt;
</code></pre>

<p>And so on.</p>

<p>Endianness only makes sense for integers and some UTF code
point types (utf16 and utf32).</p>

<p>Finally, we can also specify size and unit for each segment. The
unit is multiplied by the size to give the effective size of
the segment:</p>

<pre><code>iex&gt; &lt;&lt;102, _rest :: [size(2), unit(8)]&gt;&gt; = &quot;foo&quot;
&quot;foo&quot;

iex&gt; &lt;&lt;102, _rest :: size(16)&gt;&gt; = &quot;foo&quot;
&quot;foo&quot;

iex&gt; &lt;&lt;102, _rest :: size(32)&gt;&gt; = &quot;foo&quot;
** (MatchError) no match of right hand side value: &quot;foo&quot;
</code></pre>

<p>In the example above, the first two expressions matches
because the string &quot;foo&quot; takes 24 bits and we are matching
against a segment of 24 bits as well, 8 of which are taken by
the integer 102 and the remaining 16 bits are specified on
the rest. On the last example, we expect a rest with size 32,
which won&#39;t match.</p>

<p>Size and unit are not applicable to utf8, utf16, and utf32.</p>

<p>The default size for integers is 8. For floats, it is 64. For
binaries, it is the size of the binary. Only the last binary
in a binary match can use the default size (all others must
have their size specified explicitly). Bitstrings do not have
a default size.</p>

<p>Size can also be specified using a syntax shortcut. Instead of
writing <code>size(8)</code>, one can write just <code>8</code> and it will be interpreted
as <code>size(8)</code></p>

<pre><code>iex&gt; &lt;&lt; 1 :: 3 &gt;&gt; == &lt;&lt; 1 :: size(3) &gt;&gt;
true
</code></pre>

<p>The default unit for integers, floats, and bitstrings is 1. For
binaries, it is 8.</p>

<p>For floats, unit * size must result in 32 or 64, corresponding
to binary32 and binary64, respectively.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L302" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="^/1">
    <span class="signature"><strong>^var</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#^/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Accesses an already bound variable in match clauses.</p>

<h2>Examples</h2>

<p>Elixir allows variables to be rebound via static single assignment:</p>

<pre><code>iex&gt; x = 1
iex&gt; x = 2
iex&gt; x
2
</code></pre>

<p>However, in some situations, it is useful to match against an existing
value, instead of rebinding. This can be done with the <code>^</code> special form:</p>

<pre><code>iex&gt; x = 1
iex&gt; ^x = List.first([1])
iex&gt; ^x = List.first([2])
** (MatchError) no match of right hand side value: 2
</code></pre>

<p>Note that <code>^</code> always refers to the value of x prior to the match. The
following example will match:</p>

<pre><code>iex&gt; x = 0
iex&gt; {x, ^x} = {1, 0}
iex&gt; x
1
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L652" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="__CALLER__/0">
    <span class="signature"><strong>__CALLER__</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__CALLER__/0" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Returns the current calling environment as a <a href="Macro.Env.html"><code>Macro.Env</code></a> struct.</p>

<p>In the environment you can access the filename, line numbers,
set up aliases, the function and others.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L621" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="__DIR__/0">
    <span class="signature"><strong>__DIR__</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__DIR__/0" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Returns the current directory as a binary.</p>

<p>Although the directory can be accessed as <code>Path.dirname(__ENV__.file)</code>,
this macro is a convenient shortcut.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L613" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="__ENV__/0">
    <span class="signature"><strong>__ENV__</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__ENV__/0" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Returns the current environment information as a <a href="Macro.Env.html"><code>Macro.Env</code></a> struct.</p>

<p>In the environment you can access the current filename,
line numbers, set up aliases, the current function and others.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L597" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="__MODULE__/0">
    <span class="signature"><strong>__MODULE__</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__MODULE__/0" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Returns the current module name as an atom or <code>nil</code> otherwise.</p>

<p>Although the module can be accessed in the <code>__ENV__</code>, this macro
is a convenient shortcut.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L605" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="__aliases__/1">
    <span class="signature"><strong>__aliases__(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__aliases__/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Internal special form to hold aliases information.</p>

<p>It is usually compiled to an atom:</p>

<pre><code>iex&gt; quote do: Foo.Bar
{:__aliases__, [alias: false], [:Foo, :Bar]}
</code></pre>

<p>Elixir represents <code>Foo.Bar</code> as <code>__aliases__</code> so calls can be
unambiguously identified by the operator <code>:.</code>. For example:</p>

<pre><code>iex&gt; quote do: Foo.bar
{{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}
</code></pre>

<p>Whenever an expression iterator sees a <code>:.</code> as the tuple key,
it can be sure that it represents a call and the second argument
in the list is an atom.</p>

<p>On the other hand, aliases holds some properties:</p>

<ol>
<li><p>The head element of aliases can be any term.</p></li>
<li><p>The tail elements of aliases are guaranteed to always be atoms.</p></li>
<li><p>When the head element of aliases is the atom <code>:Elixir</code>, no expansion happen.</p></li>
<li><p>When the head element of aliases is not an atom, it is expanded at runtime:</p>

<pre><code> quote do: some_var.Foo
 {:__aliases__, [], [{:some_var, [], Elixir}, :Foo]}
</code></pre>

<p>Since <code>some_var</code> is not available at compilation time, the compiler
 expands such expression to:</p>

<pre><code> Module.concat [some_var, Foo]
</code></pre></li>
</ol>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1347" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="__block__/1">
    <span class="signature"><strong>__block__(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#__block__/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Internal special form for block expressions.</p>

<p>This is the special form used whenever we have a block
of expressions in Elixir. This special form is private
and should not be invoked directly:</p>

<pre><code>iex&gt; quote do: (1; 2; 3)
{:__block__, [], [1, 2, 3]}
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1239" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="alias/2">
    <span class="signature"><strong>alias(module, opts)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#alias/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p><code>alias</code> is used to setup aliases, often useful with modules names.</p>

<h2>Examples</h2>

<p><code>alias</code> can be used to setup an alias for any module:</p>

<pre><code>defmodule Math do
  alias MyKeyword, as: Keyword
end
</code></pre>

<p>In the example above, we have set up <code>MyKeyword</code> to be aliased
as <a href="Keyword.html"><code>Keyword</code></a>. So now, any reference to <a href="Keyword.html"><code>Keyword</code></a> will be
automatically replaced by <code>MyKeyword</code>.</p>

<p>In case one wants to access the original <a href="Keyword.html"><code>Keyword</code></a>, it can be done
by accessing <code>Elixir</code>:</p>

<pre><code>Keyword.values   #=&gt; uses MyKeyword.values
Elixir.Keyword.values #=&gt; uses Keyword.values
</code></pre>

<p>Notice that calling <code>alias</code> without the <code>as:</code> option automatically
sets an alias based on the last part of the module. For example:</p>

<pre><code>alias Foo.Bar.Baz
</code></pre>

<p>Is the same as:</p>

<pre><code>alias Foo.Bar.Baz, as: Baz
</code></pre>

<h2>Lexical scope</h2>

<p><code>import</code>, <code>require</code> and <code>alias</code> are called directives and all
have lexical scope. This means you can set up aliases inside
specific functions and it won&#39;t affect the overall scope.</p>

<h2>Warnings</h2>

<p>If you alias a module and you don&#39;t use the alias, Elixir is
going to issue a warning implying the alias is not being used.</p>

<p>In case the alias is generated automatically by a macro,
Elixir won&#39;t emit any warnings though, since the alias
was not explicitly defined.</p>

<p>Both warning behaviours could be changed by explicitly
setting the <code>:warn</code> option to true or false.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L470" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="case/2">
    <span class="signature"><strong>case(condition, blocks)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#case/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Matches the given expression against the given clauses.</p>

<h2>Examples</h2>

<pre><code>case thing do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value -&gt;
    value
end
</code></pre>

<p>In the example above, we match <code>thing</code> against each clause &quot;head&quot;
and execute the clause &quot;body&quot; corresponding to the first clause
that matches. If no clause matches, an error is raised.</p>

<h2>Variables handling</h2>

<p>Notice that variables bound in a clause &quot;head&quot; do not leak to the
outer context:</p>

<pre><code>case data do
  {:ok, value} -&gt; value
  :error -&gt; nil
end

value #=&gt; unbound variable value
</code></pre>

<p>However, variables explicitly bound in the clause &quot;body&quot; are
accessible from the outer context:</p>

<pre><code>value = 7

case lucky? do
  false -&gt; value = 13
  true  -&gt; true
end

value #=&gt; 7 or 13
</code></pre>

<p>In the example above, value is going to be <code>7</code> or <code>13</code> depending on
the value of <code>lucky?</code>. In case <code>value</code> has no previous value before
case, clauses that do not explicitly bind a value have the variable
bound to nil.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1400" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="fn/1">
    <span class="signature"><strong>fn
  [clauses]
end</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#fn/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Defines an anonymous function.</p>

<h2>Examples</h2>

<pre><code>iex&gt; add = fn a, b -&gt; a + b end
iex&gt; add.(1, 2)
3
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1226" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="for/1">
    <span class="signature"><strong>for(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#for/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Comprehensions allow you to quickly build a data structure from
an enumerable or a bitstring.</p>

<p>Let&#39;s start with an example:</p>

<pre><code>iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2
[2, 4, 6, 8]
</code></pre>

<p>A comprehension accepts many generators and filters. Enumerable
generators are defined using <code>&lt;-</code>:</p>

<pre><code># A list generator:
iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2
[2, 4, 6, 8]

# A comprehension with two generators
iex&gt; for x &lt;- [1, 2], y &lt;- [2, 3], do: x*y
[2, 3, 4, 6]
</code></pre>

<p>Filters can also be given:</p>

<pre><code># A comprehension with a generator and a filter
iex&gt; for n &lt;- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n
[2, 4, 6]
</code></pre>

<p>Note generators can also be used to filter as it removes any value
that doesn&#39;t match the left side of <code>&lt;-</code>:</p>

<pre><code>iex&gt; for {:user, name} &lt;- [user: &quot;jose&quot;, admin: &quot;john&quot;, user: &quot;eric&quot;] do
...&gt;   String.upcase(name)
...&gt; end
[&quot;JOSE&quot;, &quot;ERIC&quot;]
</code></pre>

<p>Bitstring generators are also supported and are very useful when you
need to organize bitstring streams:</p>

<pre><code>iex&gt; pixels = &lt;&lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&gt;&gt;
iex&gt; for &lt;&lt;r::8, g::8, b::8 &lt;- pixels &gt;&gt;, do: {r, g, b}
[{213,45,132},{64,76,32},{76,0,0},{234,32,15}]
</code></pre>

<p>Variable assignments inside the comprehension, be it in generators,
filters or inside the block, are not reflected outside of the
comprehension.</p>

<h2>Into</h2>

<p>In the examples above, the result returned by the comprehension was
always a list. The returned result can be configured by passing an
<code>:into</code> option, that accepts any structure as long as it implements
the <a href="Collectable.html"><code>Collectable</code></a> protocol.</p>

<p>For example, we can use bitstring generators with the <code>:into</code> option
to easily remove all spaces in a string:</p>

<pre><code>iex&gt; for &lt;&lt;c &lt;- &quot; hello world &quot;&gt;&gt;, c != ?\s, into: &quot;&quot;, do: &lt;&lt;c&gt;&gt;
&quot;helloworld&quot;
</code></pre>

<p>The <a href="IO.html"><code>IO</code></a> module provides streams, that are both <a href="Enumerable.html"><code>Enumerable</code></a> and
<a href="Collectable.html"><code>Collectable</code></a>, here is an upcase echo server using comprehensions:</p>

<pre><code>for line &lt;- IO.stream(:stdio, :line), into: IO.stream(:stdio, :line) do
  String.upcase(line)
end
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1214" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="import/2">
    <span class="signature"><strong>import(module, opts)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#import/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Imports function and macros from other modules.</p>

<p><code>import</code> allows one to easily access functions or macros from
others modules without using the qualified name.</p>

<h2>Examples</h2>

<p>If you are using several functions from a given module, you can
import those functions and reference them as local functions,
for example:</p>

<pre><code>iex&gt; import List
iex&gt; flatten([1, [2], 3])
[1,2,3]
</code></pre>

<h2>Selector</h2>

<p>By default, Elixir imports functions and macros from the given
module, except the ones starting with underscore (which are
usually callbacks):</p>

<pre><code>import List
</code></pre>

<p>A developer can filter to import only macros or functions via
the only option:</p>

<pre><code>import List, only: :functions
import List, only: :macros
</code></pre>

<p>Alternatively, Elixir allows a developer to pass pairs of
name/arities to <code>:only</code> or <code>:except</code> as a fine grained control
on what to import (or not):</p>

<pre><code>import List, only: [flatten: 1]
import String, except: [split: 2]
</code></pre>

<p>Notice that calling <code>except</code> for a previously declared <code>import</code>
simply filters the previously imported elements. For example:</p>

<pre><code>import List, only: [flatten: 1, keyfind: 3]
import List, except: [flatten: 1]
</code></pre>

<p>After the two import calls above, only <code>List.keyfind/3</code> will be
imported.</p>

<h2>Lexical scope</h2>

<p>It is important to notice that <code>import</code> is lexical. This means you
can import specific macros inside specific functions:</p>

<pre><code>defmodule Math do
  def some_function do
    # 1) Disable `if/2` from Kernel
    import Kernel, except: [if: 2]

    # 2) Require the new `if` macro from MyMacros
    import MyMacros

    # 3) Use the new macro
    if do_something, it_works
  end
end
</code></pre>

<p>In the example above, we imported macros from <code>MyMacros</code>,
replacing the original <code>if/2</code> implementation by our own
within that specific function. All other functions in that
module will still be able to use the original one.</p>

<h2>Warnings</h2>

<p>If you import a module and you don&#39;t use any of the imported
functions or macros from this module, Elixir is going to issue
a warning implying the import is not being used.</p>

<p>In case the import is generated automatically by a macro,
Elixir won&#39;t emit any warnings though, since the import
was not explicitly defined.</p>

<p>Both warning behaviours could be changed by explicitly
setting the <code>:warn</code> option to true or false.</p>

<h2>Ambiguous function/macro names</h2>

<p>If two modules <code>A</code> and <code>B</code> are imported and they both contain
a <code>foo</code> function with an arity of <code>1</code>, an error is only emitted
if an ambiguous call to <code>foo/1</code> is actually made; that is, the
errors are emitted lazily, not eagerly.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L589" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="quote/2">
    <span class="signature"><strong>quote(opts, block)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#quote/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Gets the representation of any expression.</p>

<h2>Examples</h2>

<pre><code>quote do: sum(1, 2, 3)
#=&gt; {:sum, [], [1, 2, 3]}
</code></pre>

<h2>Explanation</h2>

<p>Any Elixir code can be represented using Elixir data structures.
The building block of Elixir macros is a tuple with three elements,
for example:</p>

<pre><code>{:sum, [], [1, 2, 3]}
</code></pre>

<p>The tuple above represents a function call to <code>sum</code> passing 1, 2 and
3 as arguments. The tuple elements are:</p>

<ul>
<li><p>The first element of the tuple is always an atom or
another tuple in the same representation.</p></li>
<li><p>The second element of the tuple represents metadata.</p></li>
<li><p>The third element of the tuple are the arguments for the
function call. The third argument may be an atom, which is
usually a variable (or a local call).</p></li>
</ul>

<h2>Options</h2>

<ul>
<li><p><code>:unquote</code> - when false, disables unquoting. Useful when you have a quote
inside another quote and want to control what quote is able to unquote.</p></li>
<li><p><code>:location</code> - when set to <code>:keep</code>, keeps the current line and file from
quote. Read the Stacktrace information section below for more
information.</p></li>
<li><p><code>:context</code> - sets the resolution context.</p></li>
<li><p><code>:bind_quoted</code> - passes a binding to the macro. Whenever a binding is
given, <code>unquote</code> is automatically disabled.</p></li>
</ul>

<h2>Quote literals</h2>

<p>Besides the tuple described above, Elixir has a few literals that
when quoted return themselves. They are:</p>

<pre><code>:sum         #=&gt; Atoms
1            #=&gt; Integers
2.0          #=&gt; Floats
[1, 2]       #=&gt; Lists
&quot;strings&quot;    #=&gt; Strings
{key, value} #=&gt; Tuples with two elements
</code></pre>

<h2>Quote and macros</h2>

<p><code>quote</code> is commonly used with macros for code generation. As an exercise,
let&#39;s define a macro that multiplies a number by itself (squared). Note
there is no reason to define such as a macro (and it would actually be
seen as a bad practice), but it is simple enough that it allows us to focus
on the important aspects of quotes and macros:</p>

<pre><code>defmodule Math do
  defmacro squared(x) do
    quote do
      unquote(x) * unquote(x)
    end
  end
end
</code></pre>

<p>We can invoke it as:</p>

<pre><code>import Math
IO.puts &quot;Got #{squared(5)}&quot;
</code></pre>

<p>At first, there is nothing in this example that actually reveals it is a
macro. But what is happening is that, at compilation time, <code>squared(5)</code>
becomes <code>5 * 5</code>. The argument <code>5</code> is duplicated in the produced code, we
can see this behaviour in practice though because our macro actually has
a bug:</p>

<pre><code>import Math
my_number = fn -&gt;
  IO.puts &quot;Returning 5&quot;
  5
end
IO.puts &quot;Got #{squared(my_number.())}&quot;
</code></pre>

<p>The example above will print:</p>

<pre><code>Returning 5
Returning 5
25
</code></pre>

<p>Notice how &quot;Returning 5&quot; was printed twice, instead of just once. This is
because a macro receives an expression and not a value (which is what we
would expect in a regular function). This means that:</p>

<pre><code>squared(my_number.())
</code></pre>

<p>Actually expands to:</p>

<pre><code>my_number.() * my_number.()
</code></pre>

<p>Which invokes the function twice, explaining why we get the printed value
twice! In the majority of the cases, this is actually unexpected behaviour,
and that&#39;s why one of the first things you need to keep in mind when it
comes to macros is to <strong>not unquote the same value more than once</strong>.</p>

<p>Let&#39;s fix our macro:</p>

<pre><code>defmodule Math do
  defmacro squared(x) do
    quote do
      x = unquote(x)
      x * x
    end
  end
end
</code></pre>

<p>Now invoking <code>square(my_number.())</code> as before will print the value just
once.</p>

<p>In fact, this pattern is so common that most of the times you will want
to use the <code>bind_quoted</code> option with <code>quote</code>:</p>

<pre><code>defmodule Math do
  defmacro squared(x) do
    quote bind_quoted: [x: x] do
      x * x
    end
  end
end
</code></pre>

<p><code>:bind_quoted</code> will translate to the same code as the example above.
<code>:bind_quoted</code> can be used in many cases and is seen as good practice,
not only because it helps us from running into common mistakes but also
because it allows us to leverage other tools exposed by macros, such as
unquote fragments discussed in some sections below.</p>

<p>Before we finish this brief introduction, you will notice that, even though
we defined a variable <code>x</code> inside our quote:</p>

<pre><code>quote do
  x = unquote(x)
  x * x
end
</code></pre>

<p>When we call:</p>

<pre><code>import Math
squared(5)
x #=&gt; ** (RuntimeError) undefined function or variable: x
</code></pre>

<p>We can see that <code>x</code> did not leak to the user context. This happens
because Elixir macros are hygienic, a topic we will discuss at length
in the next sections as well.</p>

<h2>Hygiene in variables</h2>

<p>Consider the following example:</p>

<pre><code>defmodule Hygiene do
  defmacro no_interference do
    quote do: a = 1
  end
end

require Hygiene

a = 10
Hygiene.no_interference
a #=&gt; 10
</code></pre>

<p>In the example above, <code>a</code> returns 10 even if the macro
is apparently setting it to 1 because variables defined
in the macro does not affect the context the macro is executed in.
If you want to set or get a variable in the caller&#39;s context, you
can do it with the help of the <code>var!</code> macro:</p>

<pre><code>defmodule NoHygiene do
  defmacro interference do
    quote do: var!(a) = 1
  end
end

require NoHygiene

a = 10
NoHygiene.interference
a #=&gt; 1
</code></pre>

<p>Note that you cannot even access variables defined in the same
module unless you explicitly give it a context:</p>

<pre><code>defmodule Hygiene do
  defmacro write do
    quote do
      a = 1
    end
  end

  defmacro read do
    quote do
      a
    end
  end
end

Hygiene.write
Hygiene.read
#=&gt; ** (RuntimeError) undefined function or variable: a
</code></pre>

<p>For such, you can explicitly pass the current module scope as
argument:</p>

<pre><code>defmodule ContextHygiene do
  defmacro write do
    quote do
      var!(a, ContextHygiene) = 1
    end
  end

  defmacro read do
    quote do
      var!(a, ContextHygiene)
    end
  end
end

ContextHygiene.write
ContextHygiene.read
#=&gt; 1
</code></pre>

<h2>Hygiene in aliases</h2>

<p>Aliases inside quote are hygienic by default.
Consider the following example:</p>

<pre><code>defmodule Hygiene do
  alias HashDict, as: D

  defmacro no_interference do
    quote do: D.new
  end
end

require Hygiene
Hygiene.no_interference #=&gt; #HashDict&lt;[]&gt;
</code></pre>

<p>Notice that, even though the alias <code>D</code> is not available
in the context the macro is expanded, the code above works
because <code>D</code> still expands to <a href="HashDict.html"><code>HashDict</code></a>.</p>

<p>Similarly, even if we defined an alias with the same name
before invoking a macro, it won&#39;t affect the macro&#39;s result:</p>

<pre><code>defmodule Hygiene do
  alias HashDict, as: D

  defmacro no_interference do
    quote do: D.new
  end
end

require Hygiene
alias SomethingElse, as: D
Hygiene.no_interference #=&gt; #HashDict&lt;[]&gt;
</code></pre>

<p>In some cases, you want to access an alias or a module defined
in the caller. For such, you can use the <code>alias!</code> macro:</p>

<pre><code>defmodule Hygiene do
  # This will expand to Elixir.Nested.hello
  defmacro no_interference do
    quote do: Nested.hello
  end

  # This will expand to Nested.hello for
  # whatever is Nested in the caller
  defmacro interference do
    quote do: alias!(Nested).hello
  end
end

defmodule Parent do
  defmodule Nested do
    def hello, do: &quot;world&quot;
  end

  require Hygiene
  Hygiene.no_interference
  #=&gt; ** (UndefinedFunctionError) ...

  Hygiene.interference
  #=&gt; &quot;world&quot;
end
</code></pre>

<h2>Hygiene in imports</h2>

<p>Similar to aliases, imports in Elixir are hygienic. Consider the
following code:</p>

<pre><code>defmodule Hygiene do
  defmacrop get_size do
    quote do
      size(&quot;hello&quot;)
    end
  end

  def return_size do
    import Kernel, except: [size: 1]
    get_size
  end
end

Hygiene.return_size #=&gt; 5
</code></pre>

<p>Notice how <code>return_size</code> returns 5 even though the <code>size/1</code>
function is not imported. In fact, even if <code>return_size</code> imported
a function from another module, it wouldn&#39;t affect the function
result:</p>

<pre><code>def return_size do
  import Dict, only: [size: 1]
  get_size
end
</code></pre>

<p>Calling this new <code>return_size</code> will still return 5 as result.</p>

<p>Elixir is smart enough to delay the resolution to the latest
moment possible. So, if you call <code>size(&quot;hello&quot;)</code> inside quote,
but no <code>size/1</code> function is available, it is then expanded in
the caller:</p>

<pre><code>defmodule Lazy do
  defmacrop get_size do
    import Kernel, except: [size: 1]

    quote do
      size([a: 1, b: 2])
    end
  end

  def return_size do
    import Kernel, except: [size: 1]
    import Dict, only: [size: 1]
    get_size
  end
end

Lazy.return_size #=&gt; 2
</code></pre>

<h2>Stacktrace information</h2>

<p>When defining functions via macros, developers have the option of
choosing if runtime errors will be reported from the caller or from
inside the quote. Let&#39;s see an example:</p>

<pre><code># adder.ex
defmodule Adder do
  @doc &quot;Defines a function that adds two numbers&quot;
  defmacro defadd do
    quote location: :keep do
      def add(a, b), do: a + b
    end
  end
end

# sample.ex
defmodule Sample do
  import Adder
  defadd
end
</code></pre>

<p>When using <code>location: :keep</code> and invalid arguments are given to
<code>Sample.add/2</code>, the stacktrace information will point to the file
and line inside the quote. Without <code>location: :keep</code>, the error is
reported to where <code>defadd</code> was invoked. Note <code>location: :keep</code> affects
only definitions inside the quote.</p>

<h2>Binding and unquote fragments</h2>

<p>Elixir quote/unquote mechanisms provides a functionality called
unquote fragments. Unquote fragments provide an easy way to generate
functions on the fly. Consider this example:</p>

<pre><code>kv = [foo: 1, bar: 2]
Enum.each kv, fn {k, v} -&gt;
  def unquote(k)(), do: unquote(v)
end
</code></pre>

<p>In the example above, we have generated the functions <code>foo/0</code> and
<code>bar/0</code> dynamically. Now, imagine that, we want to convert this
functionality into a macro:</p>

<pre><code>defmacro defkv(kv) do
  Enum.map kv, fn {k, v} -&gt;
    quote do
      def unquote(k)(), do: unquote(v)
    end
  end
end
</code></pre>

<p>We can invoke this macro as:</p>

<pre><code>defkv [foo: 1, bar: 2]
</code></pre>

<p>However, we can&#39;t invoke it as follows:</p>

<pre><code>kv = [foo: 1, bar: 2]
defkv kv
</code></pre>

<p>This is because the macro is expecting its arguments to be a
keyword list at <strong>compilation</strong> time. Since in the example above
we are passing the representation of the variable <code>kv</code>, our
code fails.</p>

<p>This is actually a common pitfall when developing macros. We are
assuming a particular shape in the macro. We can work around it
by unquoting the variable inside the quoted expression:</p>

<pre><code>defmacro defkv(kv) do
  quote do
    Enum.each unquote(kv), fn {k, v} -&gt;
      def unquote(k)(), do: unquote(v)
    end
  end
end
</code></pre>

<p>If you try to run our new macro, you will notice it won&#39;t
even compile, complaining that the variables <code>k</code> and <code>v</code>
does not exist. This is because of the ambiguity: <code>unquote(k)</code>
can either be an unquote fragment, as previously, or a regular
unquote as in <code>unquote(kv)</code>.</p>

<p>One solution to this problem is to disable unquoting in the
macro, however, doing that would make it impossible to inject the
<code>kv</code> representation into the tree. That&#39;s when the <code>:bind_quoted</code>
option comes to the rescue (again!). By using <code>:bind_quoted</code>, we
can automatically disable unquoting while still injecting the
desired variables into the tree:</p>

<pre><code>defmacro defkv(kv) do
  quote bind_quoted: [kv: kv] do
    Enum.each kv, fn {k, v} -&gt;
      def unquote(k)(), do: unquote(v)
    end
  end
end
</code></pre>

<p>In fact, the <code>:bind_quoted</code> option is recommended every time
one desires to inject a value into the quote.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1108" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="receive/1">
    <span class="signature"><strong>receive(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#receive/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Checks if there is a message matching the given clauses
in the current process mailbox.</p>

<p>In case there is no such message, the current process hangs
until a message arrives or waits until a given timeout value.</p>

<h2>Examples</h2>

<pre><code>receive do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value when is_atom(value) -&gt;
    value
  _ -&gt;
    IO.puts :stderr, &quot;Unexpected message received&quot;
end
</code></pre>

<p>An optional after clause can be given in case the message was not
received after the specified period of time:</p>

<pre><code>receive do
  {:selector, i, value} when is_integer(i) -&gt;
    value
  value when is_atom(value) -&gt;
    value
  _ -&gt;
    IO.puts :stderr, &quot;Unexpected message received&quot;
after
  5000 -&gt;
    IO.puts :stderr, &quot;No message in 5 seconds&quot;
end
</code></pre>

<p>The <code>after</code> clause can be specified even if there are no match clauses.
There are two special cases for the timeout value given to <code>after</code></p>

<ul>
<li><p><code>:infinity</code> - the process should wait indefinitely for a matching
message, this is the same as not using a timeout</p></li>
<li><p>0 - if there is no matching message in the mailbox, the timeout
will occur immediately</p></li>
</ul>

<h2>Variables handling</h2>

<p>The <code>receive</code> special form handles variables exactly as the <code>case</code>
special macro. For more information, check the docs for <a href="#case/2"><code>case/2</code></a>.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1670" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="require/2">
    <span class="signature"><strong>require(module, opts)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#require/2" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Requires a given module to be compiled and loaded.</p>

<h2>Examples</h2>

<p>Notice that usually modules should not be required before usage,
the only exception is if you want to use the macros from a module.
In such cases, you need to explicitly require them.</p>

<p>Let&#39;s suppose you created your own <code>if</code> implementation in the module
<code>MyMacros</code>. If you want to invoke it, you need to first explicitly
require the <code>MyMacros</code>:</p>

<pre><code>defmodule Math do
  require MyMacros
  MyMacros.if do_something, it_works
end
</code></pre>

<p>An attempt to call a macro that was not loaded will raise an error.</p>

<h2>Alias shortcut</h2>

<p><code>require</code> also accepts <code>as:</code> as an option so it automatically sets
up an alias. Please check <code>alias</code> for more information.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L498" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="super/1">
    <span class="signature"><strong>super(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#super/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Calls the overriden function when overriding it with <code>defoverridable</code>.
See <code>Kernel.defoverridable</code> for more information and documentation.</p>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1353" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="try/1">
    <span class="signature"><strong>try(args)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#try/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Evaluate the given expressions and handle any error, exit
or throw that may have happened.</p>

<h2>Examples</h2>

<pre><code>try do
  do_something_that_may_fail(some_arg)
rescue
  ArgumentError -&gt;
    IO.puts &quot;Invalid argument given&quot;
catch
  value -&gt;
    IO.puts &quot;caught #{value}&quot;
else
  value -&gt;
    IO.puts &quot;Success! The result was #{value}&quot;
after
  IO.puts &quot;This is printed regardless if it failed or succeed&quot;
end
</code></pre>

<p>The rescue clause is used to handle exceptions, while the catch
clause can be used to catch thrown values. The else clause can
be used to control flow based on the result of the expression.
Catch, rescue and else clauses work based on pattern matching.</p>

<p>Note that calls inside <code>try</code> are not tail recursive since the VM
needs to keep the stacktrace in case an exception happens.</p>

<h2>Rescue clauses</h2>

<p>Besides relying on pattern matching, rescue clauses provides some
conveniences around exceptions that allows one to rescue an
exception by its name. All the following formats are valid rescue
expressions:</p>

<pre><code>try do
  UndefinedModule.undefined_function
rescue
  UndefinedFunctionError -&gt; nil
end

try do
  UndefinedModule.undefined_function
rescue
  [UndefinedFunctionError] -&gt; nil
end

# rescue and bind to x
try do
  UndefinedModule.undefined_function
rescue
  x in [UndefinedFunctionError] -&gt; nil
end

# rescue all and bind to x
try do
  UndefinedModule.undefined_function
rescue
  x -&gt; nil
end
</code></pre>

<h2>Erlang errors</h2>

<p>Erlang errors are transformed into Elixir ones during rescue:</p>

<pre><code>try do
  :erlang.error(:badarg)
rescue
  ArgumentError -&gt; :ok
end
</code></pre>

<p>The most common Erlang errors will be transformed into their
Elixir counter-part. Those which are not will be transformed
into <a href="ErlangError.html"><code>ErlangError</code></a>:</p>

<pre><code>try do
  :erlang.error(:unknown)
rescue
  ErlangError -&gt; :ok
end
</code></pre>

<p>In fact, ErlangError can be used to rescue any error that is
not an Elixir error proper. For example, it can be used to rescue
the earlier <code>:badarg</code> error too, prior to transformation:</p>

<pre><code>try do
  :erlang.error(:badarg)
rescue
  ErlangError -&gt; :ok
end
</code></pre>

<h2>Catching throws and exits</h2>

<p>The catch clause can be used to catch throws values and exits.</p>

<pre><code>try do
  exit(1)
catch
  :exit, 1 -&gt; IO.puts &quot;Exited with 1&quot;
end

try do
  throw(:sample)
catch
  :throw, :sample -&gt;
    IO.puts &quot;sample thrown&quot;
end
</code></pre>

<p>catch values also support <code>:error</code>, as in Erlang, although it is
commonly avoided in favor of raise/rescue control mechanisms.</p>

<h2>Else clauses</h2>

<p>Else clauses allow the result of the expression to be pattern
matched on:</p>

<pre><code>x = 2
try do
  1 / x
rescue
  ArithmeticError -&gt;
    :infinity
else
  y when y &lt; 1 and y &gt; -1 -&gt;
    :small
  _ -&gt;
    :large
end
</code></pre>

<p>If an else clause is not present the result of the expression will
be return, if no exceptions are raised:</p>

<pre><code>x = 1
^x =
  try do
    1 / x
  rescue
    ArithmeticError -&gt;
      :infinity
  end
</code></pre>

<p>However when an else clause is present but the result of the expression
does not match any of the patterns an exception will be raised. This
exception will not be caught by a catch or rescue in the same try:</p>

<pre><code>x = 1
try do
  try do
    1 / x
  rescue
    # The TryClauseError can not be rescued here:
    TryClauseError -&gt;
      :error_a
  else
    0 -&gt;
      :small
  end
rescue
  # The TryClauseError is rescued here:
  TryClauseError -&gt;
    :error_b
end
</code></pre>

<p>Similarly an exception inside an else clause is not caught or rescued
inside the same try:</p>

<pre><code>try do
  try do
    nil
  catch
    # The exit(1) call below can not be caught here:
    :exit, _ -&gt;
      :exit_a
  else
    _ -&gt;
      exit(1)
  end
catch
  # The exit is caught here:
  :exit, _ -&gt;
    :exit_b
end
</code></pre>

<p>This means the VM no longer needs to keep the stacktrace once inside
an else clause and so tail recursion is possible when using a <code>try</code>
with a tail call as the final call inside an else clause. The same
is true for rescue and catch clauses.</p>

<h2>Variable handling</h2>

<p>Since an expression inside <code>try</code> may not have been evaluated
due to an exception, any variable created inside <code>try</code> cannot
be accessed externally. For instance:</p>

<pre><code>try do
  x = 1
  do_something_that_may_fail(same_arg)
  :ok
catch
  _, _ -&gt; :failed
end

x #=&gt; unbound variable `x`
</code></pre>

<p>In the example above, <code>x</code> cannot be accessed since it was defined
inside the <code>try</code> clause. A common practice to address this issue
is to return the variables defined inside <code>try</code>:</p>

<pre><code>x =
  try do
    x = 1
    do_something_that_may_fail(same_arg)
    x
  catch
    _, _ -&gt; :failed
  end
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1621" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="unquote/1">
    <span class="signature"><strong>unquote(expr)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#unquote/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Unquotes the given expression from inside a macro.</p>

<h2>Examples</h2>

<p>Imagine the situation you have a variable <code>name</code> and
you want to inject it inside some quote. The first attempt
would be:</p>

<pre><code>value = 13
quote do: sum(1, value, 3)
</code></pre>

<p>Which would then return:</p>

<pre><code>{:sum, [], [1, {:value, [], quoted}, 3]}
</code></pre>

<p>Which is not the expected result. For this, we use unquote:</p>

<pre><code>value = 13
quote do: sum(1, unquote(value), 3)
#=&gt; {:sum, [], [1, 13, 3]}
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1133" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="unquote_splicing/1">
    <span class="signature"><strong>unquote_splicing(expr)</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#unquote_splicing/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Unquotes the given list expanding its arguments. Similar
to unquote.</p>

<h2>Examples</h2>

<pre><code>values = [2, 3, 4]
quote do: sum(1, unquote_splicing(values), 5)
#=&gt; {:sum, [], [1, 2, 3, 4, 5]}
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L1146" class="view_source">Source</a>
  
</div>
<div class="detail">
  <div class="detail_header" id="{}/1">
    <span class="signature"><strong>{args}</strong></span>
    <div class="detail_header_links">
      <span class="detail_type">(macro)</span>
      <a href="#{}/1" class="detail_link" title="Link to this macro">#</a>
      <a class="to_top_link" href="#content" title="To the top of the page">&uarr;</a>
    </div>
  </div>
  
  <div class="docstring"><p>Creates a tuple.</p>

<p>Only two item tuples are considered literals in Elixir.
Therefore all other tuples are represented in the AST
as a call to the special form <code>:{}</code>.</p>

<p>Conveniences for manipulating tuples can be found in the
<a href="Tuple.html"><code>Tuple</code></a> module. Some functions for working with tuples are
also available in <a href="Kernel.html"><code>Kernel</code></a>, namely <a href="Kernel.html#elem/2"><code>Kernel.elem/2</code></a>,
<a href="Kernel.html#put_elem/3"><code>Kernel.put_elem/3</code></a> and <a href="Kernel.html#tuple_size/1"><code>Kernel.tuple_size/1</code></a>.</p>

<h2>Examples</h2>

<pre><code>iex&gt; {1, 2, 3}
{1, 2, 3}

iex&gt; quote do: {1, 2, 3}
{:{}, [], [1,2,3]}
</code></pre>
</div>
  
    <a href="https://github.com/elixir-lang/elixir/blob/29f9a4fd675779ac55545151c624fd03f4dd2e2b/lib/elixir/lib/kernel/special_forms.ex#L43" class="view_source">Source</a>
  
</div>

        </div>
      

      
    </div>
  </body>
</html>
